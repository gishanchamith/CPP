<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>C++ Templates | codeHPT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
  <h1>📋 C++ Competitive Programming Templates</h1>
  <nav>
    <a href="index.html">Home</a>
    <a href="concepts.html">Concepts</a>
    <a href="competitive.html">Competitive</a>
    <a href="commands.html">Commands</a>
    <a href="algorithms.html">Algorithms</a>
    <a href="templates.html">Templates</a>
  </nav>
</header>
<main>
  <h2>Essential C++ Templates for Competitive Programming</h2>

  <div class="template-block">
    <div class="template-title">🔧 Base Template for Fast I/O and Setup</div>
    <pre><code id="code1">
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define int long long
#define all(x) x.begin(), x.end()
#define endl '\n'
#define fastio() ios::sync_with_stdio(false); cin.tie(NULL)

int32_t main() {
    fastio();
    // Your code here
    return 0;
}
    </code></pre>
    <button class="copy-btn" data-target="code1">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">📚 Input/Output Handling Template</div>
    <pre><code id="code2">
int n;
cin >> n;
vector&lt;int&gt; arr(n);
for (int i = 0; i &lt; n; ++i) cin >> arr[i];

for (int i = 0; i &lt; n; ++i) cout &lt;&lt; arr[i] &lt;&lt; " ";
cout &lt;&lt; endl;
    </code></pre>
    <button class="copy-btn" data-target="code2">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">📋 C++ STL <code>std::list</code> – Key Commands</div>
    <pre><code id="code3">
// Include header
#include &lt;list&gt;

// Create list
std::list&lt;int&gt; l;               // Empty list
std::list&lt;int&gt; l2(5, 10);       // [10, 10, 10, 10, 10]
std::list&lt;int&gt; l3 = {1, 2, 3};  // [1, 2, 3]

// Add/Remove
l.push_back(1);    // Add 1 at end
l.push_front(2);   // Add 2 at front
l.pop_back();      // Remove from end
l.pop_front();     // Remove from front

// Insert/Erase at position
auto it = l.begin(); std::advance(it, 1);
l.insert(it, 99);  // Insert 99 at 2nd position
l.erase(it);       // Erase element at iterator

// Remove by value
l.remove(99);      // Remove all 99's

// Access
int first = l.front();
int last = l.back();

// Size and check
l.size();
l.empty();
l.clear();

// Iterate
for (int x : l) std::cout &lt;&lt; x &lt;&lt; " ";

// Sort, reverse, unique
l.sort();
l.reverse();
l.unique();
    </code></pre>
    <button class="copy-btn" data-target="code3">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">🔑 C++ STL <code>std::unordered_map</code> (Hash Map) – Key Commands</div>
    <pre><code id="code4">
// Include header
#include &lt;unordered_map&gt;

// Create unordered_map
std::unordered_map&lt;std::string, int&gt; umap;

// Insert key-value pairs
umap["Alice"] = 21;
umap.insert({"Bob", 30});

// Access values
int age = umap["Alice"];
int age2 = umap.at("Bob");

// Find element
if (umap.find("Alice") != umap.end()) { /* found */ }

// Iterate
for (auto &pair : umap) {
    std::cout &lt;&lt; pair.first &lt;&lt; ": " &lt;&lt; pair.second &lt;&lt; "\n";
}

// Remove by key
umap.erase("Bob");

// Size and clear
umap.size();
umap.clear();
umap.empty();
    </code></pre>
    <button class="copy-btn" data-target="code4">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">⏫ C++ STL Heap Functions (<code>&lt;algorithm&gt;</code> on <code>vector</code>)</div>
    <pre><code id="code5">
// Include headers
#include &lt;vector&gt;
#include &lt;algorithm&gt;

// Example vector
std::vector&lt;int&gt; v = {12, 9, 15, 6, 3};

// Build a max-heap
std::make_heap(v.begin(), v.end());

// Push new value (add to vector first)
v.push_back(20);
std::push_heap(v.begin(), v.end());

// Pop max value
std::pop_heap(v.begin(), v.end());
v.pop_back();

// Get max value (top)
int max_val = v.front();

// Sort heap (ascending)
std::sort_heap(v.begin(), v.end());
    </code></pre>
    <button class="copy-btn" data-target="code5">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">💡 C++ <code>std::list</code> – Concepts & Notes</div>
    <pre><code id="code6">
- Doubly linked list (not contiguous in memory)
- Fast insert/erase anywhere (O(1) if iterator known)
- No random access by index (use iterators)
- Good for frequent insertions/deletions
- Prefer &lt;vector&gt; for fast random access
    </code></pre>
    <button class="copy-btn" data-target="code6">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">📚 C++ STL <code>stack</code></div>
    <pre><code id="code7">
// Stack = LIFO (Last In, First Out)
#include &lt;stack&gt;
std::stack&lt;int&gt; s;
s.push(10);      // Add 10
s.push(20);      // Add 20 (top)
s.top();         // Get top element (20)
s.pop();         // Remove top (now 10 is top)
s.empty();       // Check if empty
s.size();        // Number of elements
    </code></pre>
    <button class="copy-btn" data-target="code7">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">📚 C++ STL <code>queue</code></div>
    <pre><code id="code8">
// Queue = FIFO (First In, First Out)
#include &lt;queue&gt;
std::queue&lt;int&gt; q;
q.push(10);      // Add 10
q.push(20);      // Add 20
q.front();       // First element (10)
q.back();        // Last element (20)
q.pop();         // Remove first (now 20 is front)
q.empty();       // Check if empty
q.size();        // Number of elements
    </code></pre>
    <button class="copy-btn" data-target="code8">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">📚 C++ STL <code>deque</code></div>
    <pre><code id="code9">
// Deque = Double-ended queue
#include &lt;deque&gt;
std::deque&lt;int&gt; dq;
dq.push_back(10);    // [10]
dq.push_front(5);    // [5, 10]
dq.push_back(15);    // [5, 10, 15]
dq.pop_front();      // [10, 15]
dq.front();          // 10
dq.back();           // 15
dq.empty();          // Check if empty
dq.size();           // Number of elements
    </code></pre>
    <button class="copy-btn" data-target="code9">Copy</button>
  </div>

  <!-- 🌳 Tree Structure (Binary Tree) -->
<div class="template-block">
  <div class="template-title">🌳 Binary Tree Node Structure</div>
  <pre><code id="tree1">
struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int v) : val(v), left(nullptr), right(nullptr) {}
};
// Traversals
void inorder(TreeNode* root) {
    if (!root) return;
    inorder(root->left);
    cout << root->val << " ";
    inorder(root->right);
}
void preorder(TreeNode* root) {
    if (!root) return;
    cout << root->val << " ";
    preorder(root->left);
    preorder(root->right);
}
void postorder(TreeNode* root) {
    if (!root) return;
    postorder(root->left);
    postorder(root->right);
    cout << root->val << " ";
}
  </code></pre>
  <button class="copy-btn" data-target="tree1">Copy</button>
</div>

<!-- 🌳 Generic Tree (adjacency list) -->
<div class="template-block">
  <div class="template-title">🌳 General Tree (Adjacency List)</div>
  <pre><code id="tree2">
int n; // number of nodes
vector<vector<int>> tree(n); // 0-based node indexing

// Add edge: tree[u].push_back(v); tree[v].push_back(u);
// DFS Tree Traversal
void dfs(int node, int parent) {
    for (int child : tree[node]) {
        if (child != parent) {
            dfs(child, node);
        }
    }
}
  </code></pre>
  <button class="copy-btn" data-target="tree2">Copy</button>
</div>

<!-- Graph Representations -->
<div class="template-block">
  <div class="template-title">🌐 Graph Representations</div>
  <pre><code id="graph1">
// 1. Adjacency List (most common)
int n;
vector<vector<int>> adj(n);
// add edge: adj[u].push_back(v); adj[v].push_back(u); // undirected

// 2. Adjacency Matrix (for dense/small graphs)
vector<vector<int>> mat(n, vector<int>(n, 0));
// add edge: mat[u][v] = 1;

// 3. Edge List
vector<pair<int, int>> edges;
// add edge: edges.push_back({u, v});
  </code></pre>
  <button class="copy-btn" data-target="graph1">Copy</button>
</div>

<!-- MST: Kruskal's Algorithm -->
<div class="template-block">
  <div class="template-title">🌉 Kruskal's Algorithm (MST, O(E log E))</div>
  <pre><code id="mst1">
struct DSU {
    vector<int> p;
    DSU(int n): p(n) { iota(p.begin(), p.end(), 0); }
    int find(int x) { return x == p[x] ? x : p[x] = find(p[x]); }
    bool unite(int x, int y) {
        x = find(x); y = find(y);
        if (x == y) return false;
        p[y] = x; return true;
    }
};

struct Edge { int u, v, w; };
vector<Edge> edges;
int kruskal(int n) {
    sort(edges.begin(), edges.end(), [](Edge a, Edge b){ return a.w < b.w; });
    DSU dsu(n); int mst = 0;
    for (auto& e : edges)
        if (dsu.unite(e.u, e.v)) mst += e.w;
    return mst;
}
  </code></pre>
  <button class="copy-btn" data-target="mst1">Copy</button>
</div>

<!-- MST: Prim's Algorithm -->
<div class="template-block">
  <div class="template-title">🏗️ Prim's Algorithm (MST, O(E log V))</div>
  <pre><code id="mst2">
int prim(int n, vector<vector<pair<int,int>>> &adj) {
    vector<bool> vis(n, false);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    pq.push({0, 0}); int cost = 0;
    while (!pq.empty()) {
        auto [w,u] = pq.top(); pq.pop();
        if (vis[u]) continue;
        vis[u] = true; cost += w;
        for (auto &[v, wt] : adj[u])
            if (!vis[v]) pq.push({wt, v});
    }
    return cost;
}
  </code></pre>
  <button class="copy-btn" data-target="mst2">Copy</button>
</div>

<!-- Single Source Shortest Path (BFS, Dijkstra, Bellman-Ford, SPFA) -->
<div class="template-block">
  <div class="template-title">🚀 Single Source Shortest Path</div>
  <pre><code id="ssp1">
// BFS for unweighted graphs
vector<int> dist(n, -1);
queue<int> q; dist[src] = 0; q.push(src);
while (!q.empty()) {
    int u = q.front(); q.pop();
    for (int v : adj[u]) if (dist[v] == -1)
        dist[v] = dist[u] + 1, q.push(v);
}

// Dijkstra (for positive weights)
priority_queue<pair<long long, int>, vector<pair<long long,int>>, greater<>> pq;
vector<long long> d(n, LLONG_MAX); d[src] = 0; pq.push({0, src});
while (!pq.empty()) {
    auto [du, u] = pq.top(); pq.pop();
    if (du > d[u]) continue;
    for (auto &[v, w] : adj[u])
        if (d[v] > d[u]+w) d[v] = d[u]+w, pq.push({d[v], v});
}

// Bellman-Ford (handles negative weights)
vector<long long> dist(n, LLONG_MAX); dist[src] = 0;
for (int i = 0; i < n-1; ++i)
  for (auto &[u,v,w]: edges)
    if (dist[u]!=LLONG_MAX && dist[v]>dist[u]+w)
        dist[v]=dist[u]+w;
  </code></pre>
  <button class="copy-btn" data-target="ssp1">Copy</button>
</div>

<!-- SPFA (Shortest Path Faster Algorithm) -->
<div class="template-block">
  <div class="template-title">⚡ SPFA (Shortest Path Faster Algorithm)</div>
  <pre><code id="ssp2">
vector<long long> spfa(int n, int src, vector<vector<pair<int,int>>> &adj) {
    vector<long long> d(n, LLONG_MAX); d[src] = 0;
    vector<bool> inq(n, false); queue<int> q; q.push(src); inq[src]=1;
    while (!q.empty()) {
        int u = q.front(); q.pop(); inq[u]=0;
        for (auto &[v,w] : adj[u])
            if (d[v] > d[u]+w) {
                d[v]=d[u]+w;
                if (!inq[v]) q.push(v), inq[v]=1;
            }
    }
    return d;
}
  </code></pre>
  <button class="copy-btn" data-target="ssp2">Copy</button>
</div>

<!-- Algorithmic Techniques -->
<div class="template-block">
  <div class="template-title">🛠️ Algorithm Design Techniques</div>
  <pre><code id="algo1">
// Recursion
int f(int n) { return (n <= 1) ? 1 : n * f(n-1); }

// Divide & Conquer: Merge Sort
void mergeSort(vector<int>& a, int l, int r) {
    if (r - l <= 1) return;
    int m = (l + r) / 2;
    mergeSort(a, l, m); mergeSort(a, m, r);
    vector<int> tmp;
    int i = l, j = m;
    while (i < m && j < r) tmp.push_back(a[i]<a[j]?a[i++]:a[j++]);
    while (i < m) tmp.push_back(a[i++]);
    while (j < r) tmp.push_back(a[j++]);
    for (int k = l; k < r; ++k) a[k] = tmp[k-l];
}

// Two Pointers
int l = 0, r = 0, sum = 0;
while (r < n) {
    sum += a[r++];
    while (sum > X) sum -= a[l++];
}

// Sliding Window
int maxSum = 0, sum = 0, k = 3;
for (int i = 0; i < n; ++i) {
    sum += a[i];
    if (i >= k) sum -= a[i - k];
    if (i >= k-1) maxSum = max(maxSum, sum);
}

// Greedy: Activity Selection
vector<pair<int,int>> a(n);
sort(a.begin(), a.end(), [](auto x, auto y){ return x.second < y.second; });
int count = 0, last = -1;
for (auto [s,e] : a) if (s > last) last = e, ++count;

// DP: 0/1 Knapsack
int W = ...;
vector<vector<int>> dp(n+1, vector<int>(W+1,0));
for(int i=1;i<=n;++i) for(int w=0;w<=W;++w)
    if (w >= wt[i-1]) dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i-1]]+val[i-1]);
    else dp[i][w] = dp[i-1][w];
  </code></pre>
  <button class="copy-btn" data-target="algo1">Copy</button>
</div>

<!-- Bit Tricks -->
<div class="template-block">
  <div class="template-title">💡 Useful Bit Manipulation</div>
  <pre><code id="bits1">
// Count set bits
int bits = __builtin_popcount(x);      // for int
int bitsll = __builtin_popcountll(x);  // for long long

// Check if x is power of two
bool isPow2 = x && !(x & (x - 1));

// Get lowest set bit
int lsb = x & -x;

// Set/unset/toggle kth bit
x |= (1 << k);    // set
x &= ~(1 << k);   // unset
x ^= (1 << k);    // toggle

// Iterate all subsets of a set
for (int mask = s; mask; mask = (mask-1)&s) { /*...*/ }
  </code></pre>
  <button class="copy-btn" data-target="bits1">Copy</button>
</div>

  <!-- CONTINUE WITH YOUR OTHER TEMPLATES HERE AS BEFORE ... -->

</main>
<footer>
  © 2025 codeHPT by Gishan Chamith
</footer>
<script src="script.js"></script>
</body>
</html>
