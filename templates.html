<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>C++ Templates | codeHPT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
  <h1>📋 C++ Competitive Programming Templates</h1>
  <nav>
    <a href="index.html">Home</a>
    <a href="concepts.html">Concepts</a>
    <a href="competitive.html">Competitive</a>
    <a href="commands.html">Commands</a>
    <a href="algorithms.html">Algorithms</a>
    <a href="templates.html">Templates</a>
  </nav>
</header>
<main>
  <h2>Essential C++ Templates for Competitive Programming</h2>

  <!-- Template Block Example -->
  <div class="template-block">
    <div class="template-title">🔧 Base Template for Fast I/O and Setup</div>
    <pre><code id="code1">
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define int long long  // optional: change to int64_t for large constraints
#define all(x) x.begin(), x.end()
#define endl '\\n'      // fast newline
#define fastio() ios::sync_with_stdio(false); cin.tie(NULL)

int32_t main() {
    fastio();
    // Your code here
    return 0;
}
    </code></pre>
    <button class="copy-btn" data-target="code1">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">📚 Input/Output Handling Template</div>
    <pre><code id="code2">
int n;
cin >> n;
vector&lt;int&gt; arr(n);
for (int i = 0; i &lt; n; ++i) cin >> arr[i];

for (int i = 0; i &lt; n; ++i) cout &lt;&lt; arr[i] &lt;&lt; " ";
cout &lt;&lt; endl;
    </code></pre>
    <button class="copy-btn" data-target="code2">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">🧩 Modular Arithmetic Template</div>
    <pre><code id="code3">
const int MOD = 1e9 + 7;

int add(int a, int b) { return (a + b) % MOD; }
int sub(int a, int b) { return (a - b + MOD) % MOD; }
int mul(int a, int b) { return (a * b) % MOD; }
int power(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = mul(res, a);
        a = mul(a, a);
        b >>= 1;
    }
    return res;
}
int inv(int a) { return power(a, MOD - 2); } // MOD must be prime
    </code></pre>
    <button class="copy-btn" data-target="code3">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">🔁 Binary Search Template</div>
    <pre><code id="code4">
int binary_search(vector&lt;int&gt; &a, int target) {
    int lo = 0, hi = a.size() - 1;
    while (lo &lt;= hi) {
        int mid = lo + (hi - lo) / 2;
        if (a[mid] == target) return mid;
        else if (a[mid] &lt; target) lo = mid + 1;
        else hi = mid - 1;
    }
    return -1;
}
    </code></pre>
    <button class="copy-btn" data-target="code4">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">🌲 DFS/BFS Template</div>
    <pre><code id="code5">
void dfs(int node, vector&lt;vector&lt;int&gt;&gt; &adj, vector&lt;bool&gt; &visited) {
    visited[node] = true;
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, adj, visited);
        }
    }
}

void bfs(int start, vector&lt;vector&lt;int&gt;&gt; &adj, vector&lt;bool&gt; &visited) {
    queue&lt;int&gt; q;
    q.push(start);
    visited[start] = true;
    while (!q.empty()) {
        int node = q.front(); q.pop();
        for (int neighbor : adj[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}
    </code></pre>
    <button class="copy-btn" data-target="code5">Copy</button>
  </div>

  <div class="template-block">
    <div class="template-title">📦 Union-Find (DSU)</div>
    <pre><code id="code6">
vector&lt;int&gt; parent, size;
void make_set(int v) { parent[v] = v; size[v] = 1; }
int find_set(int v) { return (v == parent[v] ? v : parent[v] = find_set(parent[v])); }
void union_sets(int a, int b) {
    a = find_set(a); b = find_set(b);
    if (a != b) {
        if (size[a] < size[b]) swap(a, b);
        parent[b] = a; size[a] += size[b];
    }
}
    </code></pre>
    <button class="copy-btn" data-target="code6">Copy</button>
  </div>
 <div class="template-block">
  <div class="template-title">🧮 Fenwick Tree / Binary Indexed Tree</div>
  <pre><code id="code7">
struct FenwickTree {
    vector<long long> bit;
    int n;
    FenwickTree(int n) : n(n), bit(n+1) {}
    void add(int idx, long long val) {
        for (++idx; idx <= n; idx += idx & -idx)
            bit[idx] += val;
    }
    long long sum(int idx) {
        long long res = 0;
        for (++idx; idx > 0; idx -= idx & -idx)
            res += bit[idx];
        return res;
    }
    long long range(int l, int r) { // sum [l, r]
        return sum(r) - sum(l-1);
    }
};
  </code></pre>
  <button class="copy-btn" data-target="code7">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🔠 Trie (Prefix Tree)</div>
  <pre><code id="code8">
struct TrieNode {
    TrieNode* child[26] = {};
    bool end = false;
};
struct Trie {
    TrieNode root;
    void insert(const string &s) {
        TrieNode *node = &root;
        for (char c : s) {
            if (!node->child[c - 'a']) node->child[c - 'a'] = new TrieNode();
            node = node->child[c - 'a'];
        }
        node->end = true;
    }
    bool search(const string &s) {
        TrieNode *node = &root;
        for (char c : s) {
            if (!node->child[c - 'a']) return false;
            node = node->child[c - 'a'];
        }
        return node->end;
    }
};
  </code></pre>
  <button class="copy-btn" data-target="code8">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🧮 Sieve of Eratosthenes (Prime numbers)</div>
  <pre><code id="code9">
vector<bool> sieve(int n) {
    vector<bool> is_prime(n+1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= n; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i)
                is_prime[j] = false;
        }
    }
    return is_prime;
}
  </code></pre>
  <button class="copy-btn" data-target="code9">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🧮 Binary Exponentiation</div>
  <pre><code id="code10">
long long binpow(long long a, long long b, long long mod) {
    long long res = 1; a %= mod;
    while(b > 0) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
  </code></pre>
  <button class="copy-btn" data-target="code10">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🧮 GCD &amp; LCM</div>
  <pre><code id="code11">
long long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }
long long lcm(long long a, long long b) { return a / gcd(a, b) * b; }
  </code></pre>
  <button class="copy-btn" data-target="code11">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🔢 Debug Template (for Local Debugging)</div>
  <pre><code id="code12">
#ifdef LOCAL
#define debug(x) cerr << #x << " = "; _print(x); cerr << endl;
#else
#define debug(x)
#endif

void _print(int x) { cerr << x; }
void _print(long long x) { cerr << x; }
void _print(string x) { cerr << x; }
template &lt;class T&gt; void _print(vector&lt;T&gt; v) {
    cerr &lt;&lt; "[ "; for (T i : v) cerr &lt;&lt; i &lt;&lt; " "; cerr &lt;&lt; "]";
}
  </code></pre>
  <button class="copy-btn" data-target="code12">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">📉 Topological Sort (Kahn's Algorithm)</div>
  <pre><code id="code13">
vector<int> topo_sort(int n, vector<vector<int>>& adj) {
    vector<int> indeg(n), res;
    for (auto& u : adj) for (int v : u) ++indeg[v];
    queue<int> q;
    for (int i = 0; i < n; ++i) if (!indeg[i]) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop(); res.push_back(u);
        for (int v : adj[u])
            if (--indeg[v] == 0) q.push(v);
    }
    return res;
}
  </code></pre>
  <button class="copy-btn" data-target="code13">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🧮 Fenwick Tree / Binary Indexed Tree</div>
  <pre><code id="code7">
struct FenwickTree {
    vector<long long> bit;
    int n;
    FenwickTree(int n) : n(n), bit(n+1) {}
    void add(int idx, long long val) {
        for (++idx; idx <= n; idx += idx & -idx)
            bit[idx] += val;
    }
    long long sum(int idx) {
        long long res = 0;
        for (++idx; idx > 0; idx -= idx & -idx)
            res += bit[idx];
        return res;
    }
    long long range(int l, int r) { // sum [l, r]
        return sum(r) - sum(l-1);
    }
};
  </code></pre>
  <button class="copy-btn" data-target="code7">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🔠 Trie (Prefix Tree)</div>
  <pre><code id="code8">
struct TrieNode {
    TrieNode* child[26] = {};
    bool end = false;
};
struct Trie {
    TrieNode root;
    void insert(const string &s) {
        TrieNode *node = &root;
        for (char c : s) {
            if (!node->child[c - 'a']) node->child[c - 'a'] = new TrieNode();
            node = node->child[c - 'a'];
        }
        node->end = true;
    }
    bool search(const string &s) {
        TrieNode *node = &root;
        for (char c : s) {
            if (!node->child[c - 'a']) return false;
            node = node->child[c - 'a'];
        }
        return node->end;
    }
};
  </code></pre>
  <button class="copy-btn" data-target="code8">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🧮 Sieve of Eratosthenes (Prime numbers)</div>
  <pre><code id="code9">
vector<bool> sieve(int n) {
    vector<bool> is_prime(n+1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= n; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j <= n; j += i)
                is_prime[j] = false;
        }
    }
    return is_prime;
}
  </code></pre>
  <button class="copy-btn" data-target="code9">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🧮 Binary Exponentiation</div>
  <pre><code id="code10">
long long binpow(long long a, long long b, long long mod) {
    long long res = 1; a %= mod;
    while(b > 0) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
  </code></pre>
  <button class="copy-btn" data-target="code10">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🧮 GCD &amp; LCM</div>
  <pre><code id="code11">
long long gcd(long long a, long long b) { return b == 0 ? a : gcd(b, a % b); }
long long lcm(long long a, long long b) { return a / gcd(a, b) * b; }
  </code></pre>
  <button class="copy-btn" data-target="code11">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🔢 Debug Template (for Local Debugging)</div>
  <pre><code id="code12">
#ifdef LOCAL
#define debug(x) cerr << #x << " = "; _print(x); cerr << endl;
#else
#define debug(x)
#endif

void _print(int x) { cerr << x; }
void _print(long long x) { cerr << x; }
void _print(string x) { cerr << x; }
template &lt;class T&gt; void _print(vector&lt;T&gt; v) {
    cerr &lt;&lt; "[ "; for (T i : v) cerr &lt;&lt; i &lt;&lt; " "; cerr &lt;&lt; "]";
}
  </code></pre>
  <button class="copy-btn" data-target="code12">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">📉 Topological Sort (Kahn's Algorithm)</div>
  <pre><code id="code13">
vector<int> topo_sort(int n, vector<vector<int>>& adj) {
    vector<int> indeg(n), res;
    for (auto& u : adj) for (int v : u) ++indeg[v];
    queue<int> q;
    for (int i = 0; i < n; ++i) if (!indeg[i]) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop(); res.push_back(u);
        for (int v : adj[u])
            if (--indeg[v] == 0) q.push(v);
    }
    return res;
}
  </code></pre>
  <button class="copy-btn" data-target="code13">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🚦 Dijkstra's Algorithm</div>
  <pre><code id="code14">
vector<long long> dijkstra(int n, int src, vector<vector<pair<int, int>>> &adj) {
    vector<long long> dist(n, LLONG_MAX); dist[src] = 0;
    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<>> pq;
    pq.push({0, src});
    while(!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d > dist[u]) continue;
        for (auto &[v, w] : adj[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}
  </code></pre>
  <button class="copy-btn" data-target="code14">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🧮 Bellman-Ford Algorithm</div>
  <pre><code id="code15">
vector<long long> bellman_ford(int n, int src, vector<tuple<int,int,int>> &edges) {
    vector<long long> dist(n, LLONG_MAX);
    dist[src] = 0;
    for (int i = 0; i < n-1; ++i)
        for (auto &[u, v, w] : edges)
            if (dist[u] != LLONG_MAX && dist[v] > dist[u] + w)
                dist[v] = dist[u] + w;
    // To check for negative cycle: one more loop, if still relaxed, cycle exists
    return dist;
}
  </code></pre>
  <button class="copy-btn" data-target="code15">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🅿️ 2D Prefix Sum</div>
  <pre><code id="code16">
void compute2DPrefixSum(const vector<vector<int>>& a, vector<vector<int>>& ps) {
    int n = a.size(), m = a[0].size();
    ps.assign(n+1, vector<int>(m+1, 0));
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            ps[i][j] = a[i-1][j-1] + ps[i-1][j] + ps[i][j-1] - ps[i-1][j-1];
}
// Query sum of submatrix from (r1,c1) to (r2,c2) inclusive:
int query2D(const vector<vector<int>>& ps, int r1, int c1, int r2, int c2) {
    return ps[r2+1][c2+1] - ps[r1][c2+1] - ps[r2+1][c1] + ps[r1][c1];
}
  </code></pre>
  <button class="copy-btn" data-target="code16">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🔍 KMP String Matching</div>
  <pre><code id="code17">
vector<int> kmp(const string &s, const string &pat) {
    int n = s.size(), m = pat.size();
    vector<int> lps(m), res;
    for (int i = 1, len = 0; i < m;) {
        if (pat[i] == pat[len]) lps[i++] = ++len;
        else if (len) len = lps[len-1];
        else lps[i++] = 0;
    }
    for (int i = 0, j = 0; i < n;) {
        if (s[i] == pat[j]) ++i, ++j;
        if (j == m) res.push_back(i-j), j = lps[j-1];
        else if (i < n && s[i] != pat[j]) j ? j = lps[j-1] : ++i;
    }
    return res;
}
  </code></pre>
  <button class="copy-btn" data-target="code17">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🧮 Combinatorics: nCr modulo MOD</div>
  <pre><code id="code18">
const int N = 1e6+5, MOD = 1e9+7;
long long fact[N], invfact[N];

long long binpow(long long a, long long b, long long mod) {
    long long res = 1; a %= mod;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod; b >>= 1;
    }
    return res;
}
void init() {
    fact[0] = 1;
    for (int i = 1; i < N; ++i) fact[i] = fact[i-1] * i % MOD;
    invfact[N-1] = binpow(fact[N-1], MOD-2, MOD);
    for (int i = N-2; i >= 0; --i) invfact[i] = invfact[i+1] * (i+1) % MOD;
}
long long nCr(int n, int r) {
    if (n < r || r < 0) return 0;
    return fact[n] * invfact[r] % MOD * invfact[n-r] % MOD;
}
  </code></pre>
  <button class="copy-btn" data-target="code18">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🚩 Next Permutation</div>
  <pre><code id="code19">
vector<int> v = {1, 2, 3};
do {
    // process v
} while (next_permutation(v.begin(), v.end()));
  </code></pre>
  <button class="copy-btn" data-target="code19">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🔎 Lower Bound / Upper Bound</div>
  <pre><code id="code20">
// For sorted vector<int> v;
int x; // value to find
auto it1 = lower_bound(v.begin(), v.end(), x); // >= x
auto it2 = upper_bound(v.begin(), v.end(), x); // > x
  </code></pre>
  <button class="copy-btn" data-target="code20">Copy</button>
</div>

<div class="template-block">
  <div class="template-title">🏁 Custom Comparator for Pairs</div>
  <pre><code id="code21">
bool cmp(pair<int,int>&a, pair<int,int>&b) {
    if (a.first == b.first) return a.second > b.second;
    return a.first < b.first;
}
// sort(v.begin(), v.end(), cmp);
  </code></pre>
  <button class="copy-btn" data-target="code21">Copy</button>
</div>

 
  <!-- You can continue adding more templates using the same pattern! -->
</main>
<footer>
  © 2025 codeHPT by Gishan Chamith
</footer>
<script src="script.js"></script>
</body>
</html>
